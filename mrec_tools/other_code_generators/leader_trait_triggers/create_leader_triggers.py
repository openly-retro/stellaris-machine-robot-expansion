""" Read a trait and determine triggers for adding it to the leader """
from datetime import datetime
import time
import argparse
import sys
import os
from pathlib import Path
import pickle
import re
from multiprocessing import Process, TimeoutError

from leader_trait import (
    LEADER_MODIFIER_IDS,
    Scopes,
    LeaderClass,
    LeaderRarity,
    CustomNoneTypes,
    LeaderTrait,
    TraitGainedType,
    LeaderTier,
)

AUTOGENERATED_HEADER = f"""
######################################
# AUTOGENERATED on {str(datetime.now())}                #
######################################
"""

def make_scripted_trigger_from_trait(
    trait: LeaderTrait, generate_for_ruler: bool = False
) -> str:
    """ generate_for_ruler is used in core_modifying_effects.py """

    is_not_first_of_series = trait.identifier[-1].isdigit()
    trait_series_name = ''
    # Get the tier 1 trait name in order to refer to that scripted trigger in t2 and t3
    if is_not_first_of_series:
        trait_series_name = trait.identifier[:-2]  # drop _2 for example
    else:
        trait_series_name = trait.identifier

    # will always have the trait name in it, regardless of tier
    scripted_trigger_name = f"oxr_mdlc_leader_{trait.leader_class_identifier}_can_add_{trait_series_name}"

    triggers = []

    if is_not_first_of_series:
        """ The trait is a tier 2 or tier 3 and does not have the requierments of 
        the tier 1 trait in the trait code, so we have to make sure that the game
        checks the triggers for the tier 1 trait when adding tier 2 or 3 """
        triggers.append(
            f"{scripted_trigger_name} = yes"
        )
    if trait.leader_potential_add:
        triggers.append(trait.leader_potential_add)

    # Check class
    triggers.append(
        f"leader_class = {trait.leader_class_identifier}"
    )
    # Rarity means a level requirement
    if trait.rarity == LeaderRarity.VETERAN:
        triggers.append(f"has_base_skill >= 4")
    elif trait.rarity == LeaderRarity.PARAGON:
        triggers.append(f"has_base_skill >= 8")

    # Check for subclass
    if f"has_trait = subclass_{trait.leader_class_identifier}" in trait.leader_potential_add:
        # There might be an OR block permitting adding this trait to leaders
        # if they are of another class' subclass, but we don't care in this case
        # Just grab any subclass trait that is of this leader's class,
        # and say that's the subclass required for this veteran/paragon trait
        leader_subclass_re = r'has_trait = (subclass_' + trait.leader_class_identifier + r'_\w+)'
        subclass_match = re.search(leader_subclass_re, trait.leader_potential_add)
        subclass_trait_name = subclass_match.group(1)
        # breakpoint()

    # Put tech requirements from prerequisites into leader country check
    if trait.modifiers.get('prerequisites'):
        triggers.append(f"""
    owner = {{
        {trait.modifiers['prerequisites']}
    }}"""
        )

    if trait.modifiers.get('allowed_origins'):
        triggers.append(
            "exists = owner"
        )
        for origin in trait.modifiers['allowed_origins']:
            triggers.append(
                f"owner = {{ has_origin = {origin} }}"
            )

    if trait.modifiers.get('opposites'):
        opposites_list = [ opp_trait.strip() for opp_trait in trait.modifiers['opposites'][0].strip().split('\n') ]
        for opposite_trait in opposites_list:
            triggers.append(
                f"NOT = {{ has_trait = {opposite_trait} }}"
            )


    ########### Corrections
    # Remove is_pool_leader trigger


    ########### Put it all together
    if generate_for_ruler:
        contents = f"""
    ruler = {{
    { "\n        ".join(triggers) }
    }}
"""
    else:
        contents = f"""
oxr_mdlc_leader_{trait.leader_class_identifier}_can_add_{trait.identifier} = {{
    { "\n    ".join(triggers) }
}}
"""
    # breakpoint()
    return contents


def process_files_in_folder(subfolder, mod_folder: str, verbose=False) -> str:

    leader_class = subfolder.split(
        os.path.sep
    )[-1]

    big_scripted_trigger_file_contents = f"""
{AUTOGENERATED_HEADER}
"""
    scripted_triggers_list = []

    # Read .pickle files which are LeaderTrait objects
    file_list = Path(subfolder).glob(f'**/*.pickle')
    num_files = 0

    for trait_file_name in file_list:
        # Go thru each file, create the scripted trigger, append to big contents
        with open(trait_file_name, 'rb') as trait_file:
            trait_as_obj = pickle.load(trait_file)

        trait_scripted_trigger = make_scripted_trigger_from_trait(trait=trait_as_obj)
        scripted_triggers_list.append(trait_scripted_trigger)

    print(
        f"Processed {len(scripted_triggers_list)} scripted triggers for {subfolder} traits"
    )
    write_leader_trait_trigger_files(
        file_contents=big_scripted_trigger_file_contents + "\n".join(scripted_triggers_list),
        for_leader_class=leader_class,
        mod_folder=mod_folder
    )


def write_leader_trait_trigger_files(
    file_contents: str,
    for_leader_class: str,
    mod_folder: str
):

    file_name = f"40_mre_{for_leader_class}_leader_trait_triggers.txt"
    MOD_SCRIPTED_TRIGGERS_FOLDER = os.path.join(
        mod_folder, 'common', 'scripted_triggers'
    )
    dest_file_path = os.path.join(
        MOD_SCRIPTED_TRIGGERS_FOLDER,
        file_name
    )
    with open(dest_file_path, 'w') as dest_file:
        dest_file.write(file_contents)
    print(f"+ Wrote {for_leader_class} trait triggers to {dest_file_path}")


##################

if __name__ == "__main__":

    start_time = time.perf_counter()
    parser = argparse.ArgumentParser(
        prog="0xRetro M&RE Leader Scripted Trigger Factory",
        description="Load LeaderTrait objects and create scripted triggers from them"
    )
    parser.add_argument(
        '--build_folder',
        help="Location of mrec_tools/build, if it's not a subfolder of where this is being run",
        required=True
    )
    parser.add_argument(
        '--verbose',
        help="Print out extra information during processing",
        action='store_true',
        default=False
    )
    parser.add_argument(
        '--mod_folder',
        help="base location of mod folder",
        required=True
    )
    parser.add_argument(
        '--multiproc',
        help="Enable multiprocessing during this task",
        action="store_true",
        default=False
    )
    args = parser.parse_args()
    if not os.path.exists(args.build_folder):
        sys.exit(
            f"Couldnt find {args.build_folder}. If you didn't specify its location, then "
            "just run this from the mrec_tools folder"
        )
    traits_build_folder = os.path.join(
        args.build_folder,
        'traits_files'
    )
    if not os.path.exists(traits_build_folder):
        sys.exit(
            "Didn't see the 'traits_files' folder in the build folder. Did you run "
            "extract/split_traits_files_for_processing ?"
        )

    print(
        f"Let's nibble some files."
    )
    source_folder = os.path.join(
        traits_build_folder,
        'processed'
    )

    leader_class_subfolders = [ f.path for f in os.scandir(source_folder) if f.is_dir() ]
    print(
        f"Going to process traits in {leader_class_subfolders}"
    )

    procs = []
    for subfolder in leader_class_subfolders:
        if subfolder == 'leader':
            print("Skipping 'leader' folder")
            continue
        # We know the name of the trait already by reading the file name
        # and we know the class by which folder it's in
        if args.multiproc:
            proc = Process(
                target=process_files_in_folder,
                args=[subfolder,args.mod_folder,args.verbose]
            )
            procs.append(proc)
            proc.start()
        else:
            process_files_in_folder(subfolder, args.mod_folder, args.verbose)

    if args.multiproc:
        for proc in procs:
            proc.join()

    end_time = time.perf_counter()
    execution_time = end_time - start_time
    print(
        f"Done in {str(execution_time)[:5]} seconds"
    )
