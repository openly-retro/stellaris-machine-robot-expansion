import argparse
from datetime import datetime
import os
import time
from typing import List
import sys
from json import load as json_load

from pipeline.transform.leader_trait_triggers import process_complex_tech_requirements
from pipeline.compile.utils import write_build_file
from pipeline.mre_common_vars import (
    AUTOGENERATED_HEADER,
    BUILD_FOLDER,
    GESTALT_COUNCILOR_CLASS_MAP,
    GESTALT_COUNCILOR_SUBCLASS_MAP,
    GESTALT_COUNCILOR_TYPES,
    INPUT_FILES_FOR_CODEGEN,
    MOD_BUTTON_EFFECTS_FOLDER,
    OUTPUT_FILES_DESTINATIONS,
    TRAITS_REQUIRING_DLC,
    RARITIES,
    COUNCILOR_EDITOR,
    FILE_NUM_PREFIXES,
    GESTALT_COUNCILOR_SOURCE_TRAITS_FILES,
    CODE_HEADER,
    EXCLUDE_TRAITS_FROM_PARAGON_DLC,
)

"""
  ______ ______ ______ ______ _____ _______ _____ 
 |  ____|  ____|  ____|  ____/ ____|__   __/ ____|
 | |__  | |__  | |__  | |__ | |       | | | (___  
 |  __| |  __| |  __| |  __|| |       | |  \___ \ 
 | |____| |    | |    | |___| |____   | |  ____) |
 |______|_|    |_|    |______\_____|  |_| |_____/ 

"""

def iterate_traits_generate_reset_traits_btn_for_regulatory():
    pass

def iterate_traits_generate_reset_traits_btn_for_cognitive():
    pass

def iterate_traits_generate_reset_traits_btn_for_growth():
    pass

def iterate_traits_generate_reset_traits_btn_for_legion():
    pass

def gen_reset_trait_button_effect_for_councilors() -> List[str]:
    """ generate the trigger that determines if the reset button can be pushed
    trigger saying that any of the selectable traits are selected
    
    either generate one trigger for each, or one trigger for all
    
    go thru all 99_ files, for each class,
    iterate all the traits in councilor_editor_traits and make a set
    then return that list and print the trigger """
    unsorted_traits = {
        "common": [],
        "veteran": [],
        "paragon": []
    }
    scripted_trigger_header = """
oxr_mdlc_councilor_editor_reset_traits_button_effect = {
    potential = { always = yes }
	allow = { oxr_mdlc_councilor_editor_check_can_use_reset_button_wrapper = yes }
    effect = {
        custom_tooltip = oxr_mdlc_councilor_editor_reset_button_tooltip_1
		custom_tooltip = oxr_mdlc_councilor_editor_reset_button_tooltip_2
        hidden_effect = {
            event_target:oxr_mdlc_councilor_editor_target_@root = {
"""
    scripted_trigger_footer = """
            	oxr_mdlc_councilor_editor_reset_trait_picks_default = yes
				oxr_mdlc_councilor_editor_reset_trait_points_default = yes
			} # end of event target
        }
    }
}
"""
    indentation = "                "
    trait_limit_lines = []
    for processed_traits_file in INPUT_FILES_FOR_CODEGEN:
        with open(
            os.path.join(BUILD_FOLDER, processed_traits_file)
        ) as organized_traits_dict_data:
            organized_traits_dict = json_load(organized_traits_dict_data)
            for rarity in RARITIES:
                for leader_trait in organized_traits_dict["councilor_editor_traits"][rarity]:
                    trait_name = [*leader_trait][0]
                    if EXCLUDE_TRAITS_FROM_PARAGON_DLC.get(trait_name):
                        print(f"Skipping {trait_name}...")
                        continue
                    # deal with free_or_veteran
                    trait_rarity_level = rarity
                    if trait_rarity_level == 'free_or_veteran':
                        trait_rarity_level = 'veteran'
                    unsorted_traits[trait_rarity_level].append(trait_name)
                    
    conditional_limit = "                if = {{ limit = {{ has_trait = {trait_name} }} remove_trait = {trait_name} oxr_mdlc_councilor_editor_refund_trait_resources_cost_{rarity} = yes }}"
    # Sort them all
    for rarity in RARITIES:
        for trait_name in sorted(set(unsorted_traits[rarity])):
            trait_limit_lines.append(
                conditional_limit.format(
                    trait_name=trait_name, rarity=rarity
                )
            )
    return f"""
{scripted_trigger_header}
{"\n".join(trait_limit_lines)}
{scripted_trigger_footer}
"""


def iterate_traits_generate_button_effects_for_councilor(
        organized_traits_dict: dict,
        councilor_type: str
):
    councilor_editor_fx_blob = [AUTOGENERATED_HEADER]
    councilor_subclass = GESTALT_COUNCILOR_SUBCLASS_MAP[councilor_type]
    traits_for_councilor = []

    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['councilor_editor_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]

            if trait_req_subclass := root.get('required_subclass'):
                if trait_req_subclass != councilor_subclass:
                    print(
                        f"Skipping {trait_name}, req subclass is {trait_req_subclass}"
                        f" and this councilor is {councilor_subclass}"
                    )
                    continue

            councilor_editor_fx_code_for_trait = gen_councilor_editor_traits_button_effects_code(
                councilor_type=councilor_type,
                trait_name=trait_name,
                rarity=root['rarity'],
                required_subclass=root.get('required_subclass', None),
                prerequisites=root.get('prerequisites', [])
            )
            councilor_editor_fx_blob.append(councilor_editor_fx_code_for_trait)
            traits_for_councilor.append(trait_name)
    return '\n'.join(councilor_editor_fx_blob)


def gen_councilor_editor_traits_button_effects_code(
        councilor_type: str, trait_name: str, rarity: str, requires_paragon_dlc: bool=False,
        required_subclass: str = None, prerequisites: list = [],
):
    """ Councilors can't change class so they're restricted to just 1 class & subclass
    which means outside this code we just have to iterate one leader class' of traits """

    """ TODO: allow statements for:
    - paragon dlc
    - trait needs any dlc dependency
    - trait has any tech requirement
    MORE TODO:
    - conditionally call effect to remove T1 or T2 trait

    """
    # Figure out base trait name
    trait_ends_in_num = trait_name[-1].isdigit()
    if trait_ends_in_num:
        trait_name_no_tier = trait_name.rsplit('_',1)[0]
    else:
        trait_name_no_tier = trait_name
    
    # Calculate any additional statements to add to the "allow" block
    allowances = []
    if requires_paragon_dlc:
        allowances.append("has_paragon_dlc = yes")
    # Get fancy about picking up DLC requirements per trait
    if dlc_dependecy := TRAITS_REQUIRING_DLC.get(trait_name):
        allowances.append(f"{dlc_dependecy} = yes")
    # Assuming that prerequisites will always be tech *fingers crossed*
    if len(prerequisites):
        # for tech in prerequisites:
        #     allowances.append(f"has_technology = {tech}")
        tech_requirements = process_complex_tech_requirements(prerequisites)
        allowances = allowances + tech_requirements

    leader_class = GESTALT_COUNCILOR_CLASS_MAP[councilor_type]
    subclass_check_trigger = f"oxr_mdlc_councilor_editor_check_leader_has_required_subclass = {{ CLASS = {leader_class} SUBCLASS = {required_subclass} }}"

    if rarity == 'free_or_veteran':
        rarity = 'veteran'

    return f"""
#{councilor_type} #{trait_name} #{rarity}
oxr_mdlc_councilor_editor_{councilor_type}_{trait_name}_add_button_effect = {{
	potential = {{
		event_target:oxr_mdlc_councilor_editor_target_@root = {{ NOT = {{ has_trait = {trait_name} }} }}
	}}
	allow = {{
		custom_tooltip = xvcv_mdlc_core_modifying_tooltip_add_{leader_class}_{trait_name}
		oxr_mdlc_councilor_editor_check_trait_resources_cost_{rarity} = yes
		event_target:oxr_mdlc_councilor_editor_target_@root = {{
			oxr_mdlc_councilor_editor_check_trait_points_cost_{rarity} = yes
			oxr_mdlc_councilor_editor_check_trait_picks = yes
			oxr_mdlc_leader_{leader_class}_can_add_{trait_name_no_tier} = yes
			{"#" if required_subclass is None else ''}{subclass_check_trigger}
		}}
		{"\n        ".join(allowances)}
	}}
	effect = {{
		custom_tooltip = oxr_mdlc_councilor_editor_show_trait_total_cost_{rarity}
		event_target:oxr_mdlc_councilor_editor_target_@root = {{
			oxr_mdlc_councilor_editor_remove_tier_1_or_2_traits_effect = {{ TRAIT_NAME = {trait_name_no_tier} }}
			add_trait = {{ trait = {trait_name} show_message = no }}
		}}
		hidden_effect = {{
			oxr_mdlc_councilor_editor_deduct_trait_resources_cost_{rarity} = yes
			event_target:oxr_mdlc_councilor_editor_target_@root = {{
				oxr_mdlc_councilor_editor_deduct_trait_points_cost_{rarity} = yes
				oxr_mdlc_councilor_editor_deduct_trait_pick = yes
			}}
		}}
	}}
}}
oxr_mdlc_councilor_editor_{councilor_type}_{trait_name}_remove_button_effect = {{
	potential = {{
		event_target:oxr_mdlc_councilor_editor_target_@root = {{ has_trait = {trait_name} }}
	}}
	allow = {{ always = yes }}
	effect = {{
		custom_tooltip = xvcv_mdlc_core_modifying_tooltip_remove_{leader_class}_{trait_name}
		hidden_effect = {{
			event_target:oxr_mdlc_councilor_editor_target_@root = {{
				remove_trait = {trait_name}
				oxr_mdlc_councilor_editor_refund_trait_points_cost_{rarity} = yes
				oxr_mdlc_councilor_editor_refund_trait_pick = yes
			}}
			oxr_mdlc_councilor_editor_refund_trait_resources_cost_{rarity} = yes
		}}
	}}
}}
"""
def do_all_work():
    # Trait effects
    for councilor in GESTALT_COUNCILOR_TYPES:
        source_file = GESTALT_COUNCILOR_SOURCE_TRAITS_FILES[councilor]
        btn_fx_outfile = OUTPUT_FILES_DESTINATIONS[COUNCILOR_EDITOR]["effects"][councilor]

        traits_json_blob = ""
        with open(source_file, "r") as source_codegen_data:
            traits_json_blob = json_load(source_codegen_data)
        
        sys.stdout.write(f"Going to make {councilor} button effects code, writing to {btn_fx_outfile}...")
        councilor_gui_blob = iterate_traits_generate_button_effects_for_councilor(
            councilor_type=councilor, organized_traits_dict=traits_json_blob
        )
        with open(btn_fx_outfile, "wb") as councilor_btn_fx_outfile:
            councilor_btn_fx_outfile.write(
                councilor_gui_blob.encode('utf-8')
            )
        sys.stdout.write("Done.\n")

    # Reset button effect
    reset_traits_effect = gen_reset_trait_button_effect_for_councilors()
    reset_traits_effect_filename = f"{FILE_NUM_PREFIXES["effects"]}_oxr_mdlc_councilor_editor_reset_traits_button_effect.txt"
    # with open(
    #     os.path.join(
    #         MOD_BUTTON_EFFECTS_FOLDER,
    #         reset_traits_effect_filename
    #     ), "wb"
    # ) as outfile:
    #     outfile.write(reset_traits_effect.encode('utf-8'))

    write_build_file(
        reset_traits_effect,
        reset_traits_effect_filename,
        MOD_BUTTON_EFFECTS_FOLDER,
        "oxr_mdlc_councilor_editor_reset_traits_button_effect"
    )

    print(f"Done writing {reset_traits_effect_filename}")

if __name__ == "__main__":
    print(CODE_HEADER)
    print("Generate Councilor Editor button effects code")
    parser = argparse.ArgumentParser(
        prog="0xRetro MDLC Councilor Editor button effects generator",
        description="Create button effects for the councilor editor GUIs"
    )
    parser.add_argument(
        "--trait-effects",
        action="store_true",
        dest="trait_effects",
        help="Make all button effects for clicking on/off traits"
    )
    parser.add_argument(
        "--reset-effect",
        action="store_true",
        dest="reset_effect",
        help="Make the councilor editor trait reset button effect"
    )
    args = parser.parse_args()

    if args.trait_effects:
        for councilor in GESTALT_COUNCILOR_TYPES:
            source_file = GESTALT_COUNCILOR_SOURCE_TRAITS_FILES[councilor]
            btn_fx_outfile = OUTPUT_FILES_DESTINATIONS[COUNCILOR_EDITOR]["effects"][councilor]

            traits_json_blob = ""
            with open(source_file, "r") as source_codegen_data:
                traits_json_blob = json_load(source_codegen_data)
            
            sys.stdout.write(f"Going to make {councilor} button effects code, writing to {btn_fx_outfile}...")
            councilor_gui_blob = iterate_traits_generate_button_effects_for_councilor(
                councilor_type=councilor, organized_traits_dict=traits_json_blob
            )
            with open(btn_fx_outfile, "wb") as councilor_btn_fx_outfile:
                councilor_btn_fx_outfile.write(
                    councilor_gui_blob.encode('utf-8')
                )
            sys.stdout.write("Done."); print("")
        print("Done writing button effects code.")
    elif args.reset_effect:
        print("Going to make reset traits button effect ...")
        reset_traits_effect = gen_reset_trait_button_effect_for_councilors()
        with open(
            os.path.join(
                BUILD_FOLDER,
                f"{FILE_NUM_PREFIXES["effects"]}_oxr_mdlc_councilor_editor_reset_traits_button_effect.txt"
            ), "wb"
        ) as outfile:
            outfile.write(reset_traits_effect.encode('utf-8'))
        print("Done.")

