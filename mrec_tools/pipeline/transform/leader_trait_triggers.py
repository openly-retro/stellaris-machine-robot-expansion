""" Create scripted triggers for checking whether traits can be added to a leader via custom GUI """
from json import load as json_load
from copy import deepcopy
import json
import os
from typing import List
from pipeline.mre_common_vars import (
    BUILD_FOLDER,
    COMPILE_FOLDER,
    EXTRACT_FOLDER,
    FILE_NUM_PREFIXES,
    LEADER_CLASSES,
    MOD_SCRIPTED_TRIGGERS_FOLDER,
    CUSTOM_GUI_FEATURES,
    RARITIES,
    AUTOGENERATED_HEADER,
)
from pipeline.mre_common_utils import dict2cz
from shutil import copyfile
import pprint

pp = pprint.PrettyPrinter(indent=4)

def iterate_traits_create_requirements_triggers(traits_by_leader_class: List[dict]) -> str:
    # Create a trigger for each trait that can be added to a GUI
    triggers_list = [AUTOGENERATED_HEADER,]

    for trait in traits_by_leader_class:
        trait_name = [*trait][0]
        # Do not create triggers for traits that are tier 2, tier 3 etc
        if not trait_name[-1].isdigit():
            triggers_list.append(
                create_requirements_triggers_for_leader_traits(trait)
            )

    return "\n\n".join(triggers_list)

def write_leader_trait_trigger_files():
    for leader_class in LEADER_CLASSES:
        # pipeline_source_file = f"{FILE_NUM_PREFIXES['filtered_traits']}_mre_{leader_class}_traits_for_codegen.json"
        pipeline_source_file = f"10_mre_{leader_class}_traits.json"
        buffer = ''
        input_filename = os.path.join(EXTRACT_FOLDER, pipeline_source_file)
        with open(input_filename, "r") as input_file:
            buffer = json_load(input_file)
            # Evaluating files that are a large dict with traits sorted by feature and then rarity
            # We will surely get duplicates
            triggers_for_leader_traits = iterate_traits_create_requirements_triggers(buffer)
            output_file_name = f"{FILE_NUM_PREFIXES['triggers']}_mre_{leader_class}_leader_trait_triggers.txt"
            output_file_dest = os.path.join(
                MOD_SCRIPTED_TRIGGERS_FOLDER, output_file_name
            )
            with open(output_file_dest, 'w') as leader_triggers_output_file:
                leader_triggers_output_file.write(triggers_for_leader_traits)
            compile_folder_copy = os.path.join(
                COMPILE_FOLDER, output_file_name
            )
            copyfile(output_file_dest, compile_folder_copy)
            print(f"+ Wrote {leader_class} trait triggers to {output_file_dest}")

def process_complex_tech_requirements(tech_reqs) -> list:
    """ Fix this kind of abomination
        "prerequisites": {
            "OR": [
                "tech_cruisers",
                "tech_harbingers"
            ],
            "tech": "tech_strike_craft_1"
        },
        """
    _requirements = []

    if type(tech_reqs) == list:
        for owner_tech_req in tech_reqs:
            _requirements.append(
                f"owner = {{ has_technology = {owner_tech_req} }}"
            )
    elif type(tech_reqs) == dict:
        # breakpoint()
        reqs_keys = list(tech_reqs.keys())

        for req_data in reqs_keys:
            if req_data.startswith('tech'):
                # breakpoint()
                _requirements.append(
                    f"owner = {{ has_technology = {tech_reqs[req_data]} }}"
                )
            elif req_data == 'OR':
                # breakpoint()
                techs_in_or = tech_reqs['OR']

                # Addres OR
                owner_tech_choice_requirement = "owner = { OR = { "
                for or_tech in techs_in_or:
                    owner_tech_choice_requirement += f" has_technology = {or_tech} "
                owner_tech_choice_requirement += " } }"
                _requirements.append(owner_tech_choice_requirement)
    return _requirements

def wrangle_subclass_requirements_for_leader(root_trait_data: dict) -> List[str]:
    leader_class = root_trait_data["leader_class"]
    subclasses_set = set()
    subclass_requirements_result = ''
    if has_required_subclass := root_trait_data.get('required_subclass'):
        subclasses_set.add(root_trait_data.pop("required_subclass"))

    # Sniff for subclasses
    if "subclass_" in root_trait_data.get('leader_potential_add', ''):
        leader_specific_subclass = f'subclass_{leader}_'
        leader_subclass_search = leader_specific_subclass + r'\w*'
        matching_subclasses_list = re.findall(
            leader_subclass_search, str(root_trait_data['leader_potential_add'])
        )
        for matching_subclass in matching_subclasses_list:
            subclasses_set.add(matching_subclass)

        # We further process leader triggers later, don't double-process this one
        del root['leader_potential_add']['has_subclass_trait']

    if len(subclasses_set):
        if len(subclasses_set) > 1:

            subclasses_triggers = [
                f"has_trait = {subclass_str}"
                for subclass_str in list(subclasses)
                if leader_class in subclass_str
            ]
            trigger_or_block = f"""
    OR = {{
    {subclasses_triggers}
    }}
    """
            subclass_requirements_result = trigger_or_block
        else:
            subclass_requirements_result = f"has_trait = {list(subclasses_set)[0]}"

    return subclass_requirements_result

def create_requirements_triggers_for_leader_traits(
        trait: dict, generate_for_ruler: bool = False
    ) -> str:
    """
    Take the first leader trait in a series, pick out the requirements,
    and create a trigger for it.
    Also factor in opposites.
    """
    requirements = []
    trait_name = [*trait][0]
    if type(trait) == str:
        breakpoint()
        1
    root = trait[trait_name]
    # class
    if root == {}:
        return ''
    requirements.append(
        f"leader_class = {root["leader_class"]}"
    )
    # Deal with subclasses now
    if subclass_requirements_result := wrangle_subclass_requirements_for_leader(root):
        requirements.append(subclass_requirements_result)

    if root.get("rarity") == "veteran":
        requirements.append(
            f"has_base_skill >= 4"
        )
    elif root.get("rarity") == "paragon":
        requirements.append(
            f"has_base_skill >= 8"
        )
    elif prerequisites := root.get('prerequisites'):
        # breakpoint()
        tech_requirements = dict2cz(prerequisites)
        requirements.append(
            deepcopy(tech_requirements)
        )
        del tech_requirements

    if complex_requirements := root.get("leader_potential_add"):

        # Only try processing the skill requirements trigger
        # if either of these lines are in them
        skill_triggers_to_look_up = []
        if complex_requirements.get("has_base_skill"):
            skill_triggers_to_look_up.append('has_base_skill')
        if complex_requirements.get("has_total_skill"):
            skill_triggers_to_look_up.append('has_total_skill')

        for skill_level_trigger in skill_triggers_to_look_up:
            # "has_skill": "greater_than_1",
            value = complex_requirements[skill_level_trigger]
            skill_level = int(value.split('_')[-1])

            if value.startswith("gt_"):
                operator = ">"
            elif value.startswith("lt_"):
                operator = "<"
            elif value.startswith("gte_"):
                operator = ">="
            elif value.startswith("lte_"):
                operator = "<="
            requirements.append(
                f"{skill_level_trigger} {operator} {skill_level}"
            )
            del complex_requirements[skill_level_trigger]

    for trigger, value in root.get("leader_potential_add", {}).items():
        if trigger == "is_pool_leader":
            print(f"Skipping locking trait to 'starting only': {trait_name}")
            continue
        # Greeting abonimatnion

        elif type(value) is dict and trigger == "owner":
            
            contents = dict2cz(value)

            requirements.append(
                f"""owner = {contents.replace('\n','')}""")
        
        elif type(value) is dict and trigger.lower() == "or":

            # The test case is where there's a value like
            # {'is_gestalt': False, 'AND': {'is_gestalt': True, 'is_councilor': True}}

            contents = dict2cz(value)

            requirements.append(
                f"""OR = {contents}""")

        # if it's a standard assignment, put in the list
        elif type(value) not in [dict, list]:
            if type(value) != bool:
                requirements.append(
                    f"{trigger} = {value}"
                )
            else:
                requirements.append(
                    f"{trigger} = {'yes ' if value else 'no '}"
                )
    # QA check - we dont want stringified objects in the trigger
    if ':' in str(requirements) and not 'event_target:' in str(requirements):
        breakpoint()
    if str(requirements).count('{') != str(requirements).count('}'):
        # MISMATCH IN OPENING/CLOSING BRACES
        breakpoint()

    # Shroud help us
    if generate_for_ruler:
       return f"""
    ruler = {{
    { "\n        ".join(requirements) }
    }}
"""
    else:
        contents = f"""
oxr_mdlc_leader_{root["leader_class"]}_can_add_{trait_name} = {{
    { "\n    ".join(requirements) }
}}
"""
    return contents
