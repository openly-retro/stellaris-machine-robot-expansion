# Python code to help generate all the leader-making traits code
import argparse
from datetime import datetime
import os
from typing import List
import time
import sys
from json import load as json_load

from generate_trait_tooltips import create_tooltip_for_leader
from mre_common_vars import (
    BUILD_FOLDER,
    INPUT_FILES_FOR_CODEGEN,
    LEADER_MAKING,
    CORE_MODIFYING,
    LEADER_SUBCLASSES,
    LEADER_CLASSES,
    OUTPUT_FILES_DESTINATIONS,
    LOCALISATION_HEADER,
    LEADER_SUBCLASSES_NAMES,
    EXCLUDE_SUBCLASSES_FROM_CORE_MODIFYING,
    MACHINE_LOCALISATIONS_MAPFILE,
    EXCLUDE_TRAITS_FROM_CORE_MODIFYING,
    TRAITS_REQUIRING_DLC,
)

RARITIES = ("common", "veteran", "paragon")

AUTOGENERATED_HEADER = f"""
######################################
# AUTOGENERATED on {str(datetime.now())}                #
######################################
"""

gui_header = """
##########################################################
#       START COPY/PASTE GENERATED GUI TRAITS CODE FOR:  #
#					{classname}						 #
#   generated on {now}
##########################################################
"""
gui_footer = """
##########################################################
#       END COPY/PASTE GENERATED GUI TRAITS CODE FOR:  #
#					{classname}						 #
##########################################################
"""

def gen_core_modifying_gui_subclass_pickers_code():
    return """
#subclass_general_marshall
    containerWindowType = {
        name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall"
        position = { x = @xvcv_mdlc_core_modifying_trait_position_width_3 y = @xvcv_mdlc_core_modifying_trait_position_height_1 }
        effectbuttonType = {
            name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_add"
            position = { x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }
            spriteType = "GFX_leader_subclass_commander_general_medium"
            effect = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_add_button_effect"
        }
        effectbuttonType = {
            name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_remove"
            position = { x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }
            spriteType = "GFX_xvcv_mdlc_leader_subclass_visionary_medium_red"
            effect = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_remove_button_effect"
        }
    }
"""

### LEADER_MAKING

def gen_leader_making_trait_gui_code(
        leader_class, trait_name, column_num, row_num,
        gfx_sprite_name=None,
        is_xvcv_custom_trait=False, is_veteran_trait=False, is_destiny_trait=False
):
    """ Create code to display a trait in the xvcv_mdlc_leader_making_custom_gui.gui file """
    if not gfx_sprite_name:
        # Guess GFX name from trait name
        ends_in_num = trait_name[-1].isdigit()
        if ends_in_num:
            trait_without_level = trait_name.rsplit('_', 1)
            gfx_sprite_name = f"GFX_{trait_without_level}"
        else:
            gfx_sprite_name = f"GFX_{trait_name}"  # There will be exceptions
    effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_green"
    if is_xvcv_custom_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_blue"
    elif is_veteran_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_veteran"
    elif is_destiny_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_destiny"
    return f"""
# {leader_class}: {trait_name}
containerWindowType = {{
    name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}"
    position = {{ x = @xvcv_mdlc_leader_making_trait_position_column_{column_num} y = @xvcv_mdlc_leader_making_trait_position_row_{row_num} }}
    effectbuttonType = {{
        name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_bg"
        position = {{ x = @xvcv_mdlc_leader_making_traits_background_offset_width y = @xvcv_mdlc_leader_making_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx}"
        effect = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect"
    }}
}}
"""

def gen_leader_making_button_effects_code(
    leader_class, trait_name,
    is_veteran_trait=False, is_destiny_trait=False,
    required_subclass: str='', prerequisites: list=[],
    requires_paragon_dlc: bool=False  # Kluge to take advantage of 'requires_paragon_dlc' key
):
    # This can be used for each leader class
    # \common\button_effects\xvcv_mdlc_button_effects_leader_making_<LEADER_CLASS>_customgui.txt
    alt_trigger_name = ""
    if is_veteran_trait:
        alt_trigger_name = "alt_"
    if is_destiny_trait:
        alt_trigger_name = "alt_2_"
    vet_or_destiny_trait_comment = ''
    if is_veteran_trait:
        vet_or_destiny_trait_comment = "#veteran trait"
    if is_destiny_trait:
        vet_or_destiny_trait_comment = "#destiny trait"
    
    allowances = []
    allowances.append(
        f"xvcv_mdlc_leader_making_trait_pick_trigger = {{ CLASS = {leader_class} ID = {trait_name} }}"
    )
    if required_subclass:
        allowances.append(
            f"xvcv_mdlc_leader_making_requires_leader_subclass_trigger = {{ CLASS = {leader_class} ID = {required_subclass} }}"
        )
    allowances.append(f"xvcv_mdlc_leader_making_trait_cost_{alt_trigger_name}trigger = yes")
    allowances.append(f"xvcv_mdlc_leader_making_trait_points_{alt_trigger_name}trigger = yes")
    if is_veteran_trait or is_destiny_trait:
        allowances.append(f"xvcv_mdlc_leader_making_trait_skill_level_{alt_trigger_name}trigger = yes")
    allowances.append("xvcv_mdlc_leader_making_trait_max_number_trigger = yes")
    allowances.append(f"xvcv_mdlc_leader_making_picked_class_{leader_class}_trigger = yes")
    if requires_paragon_dlc:
        allowances.append("has_paragon_dlc = yes")
    # Assuming that prerequisites will always be tech *fingers crossed*
    if len(prerequisites):
        for tech in prerequisites:
            allowances.append(f"has_technology = {tech}")
    # Get fancy about picking up DLC requirements per trait ^^
    if dlc_dependecy := TRAITS_REQUIRING_DLC.get(trait_name):
        allowances.append(f"{dlc_dependecy} = yes")

    return f"""
#{leader_class} #{trait_name} {vet_or_destiny_trait_comment}
xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect = {{
    potential = {{ always = yes }}
    allow = {{
        {"\n        ".join(allowances)}
    }}
    effect = {{
        xvcv_mdlc_leader_making_trait_pick_effect = {{ CLASS = {leader_class} ID = {trait_name} }}
        hidden_effect = {{ xvcv_mdlc_leader_making_trait_count_points_costs_{alt_trigger_name}effect = yes }}
    }}
}}
"""

def iterate_traits_make_leadermaking_gui_code(organized_traits_dict, for_class: str) -> str:
    """ going thru a file like 99_mre_scientist_traits_for_codegen.json 
        and create code which we copy/paste into the interface/gui files
    """
    header_classname_spaced = ' '.join([char for char in for_class])
    header = gui_header.format(
        classname=header_classname_spaced,
        now=str(datetime.now())
    )
    footer = gui_footer.format(
        classname=header_classname_spaced
    )
    leader_making_code_bloblist = [header,]
    # 10 columns, 8 rows
    trait_column_num = 3  # There are 2 custom traits already coded in to the gui file
    trait_row_num = 1
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]
            trait_gui_code = gen_leader_making_trait_gui_code(
                trait_name=trait_name,
                leader_class=root['leader_class'],
                column_num=trait_column_num, row_num=trait_row_num,
                is_veteran_trait=(root['rarity']=="veteran"),
                is_destiny_trait=(root['rarity']=="paragon"),
                gfx_sprite_name=root['gfx']
            )
            trait_column_num = trait_column_num + 1
            if trait_column_num > 10:
                trait_column_num = 1
                trait_row_num = trait_row_num + 1
            leader_making_code_bloblist.append(trait_gui_code)
    leader_making_code_bloblist.append(footer)
    return ''.join(leader_making_code_bloblist)

def iterate_traits_make_leadermaking_tooltips_code(organized_traits_dict, for_class):
    leader_making_tooltips_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            tooltip_code_for_leadermaking_trait = create_tooltip_for_leader(
                trait_dict=leader_making_trait, leader_class=for_class, feature="core_modifying"
            )
            leader_making_tooltips_copypaste_blob.append(tooltip_code_for_leadermaking_trait)
    return ''.join(leader_making_tooltips_copypaste_blob)

def iterate_traits_make_leadermaking_effects_code(organized_traits_dict, for_class):
    leader_making_effects_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]
            leadermaking_effects_code_for_trait = gen_leader_making_button_effects_code(
                leader_class=for_class,
                trait_name=trait_name,
                is_veteran_trait=(root.get('rarity')=="veteran"),
                is_destiny_trait=(root.get('rarity')=="paragon"),
                required_subclass=root.get('required_subclass', None),
                prerequisites=root.get('prerequisites', [])
            )
            leader_making_effects_copypaste_blob.append(leadermaking_effects_code_for_trait)
    return '\n'.join(leader_making_effects_copypaste_blob)

def write_leadermaking_tooltips_to_file(input_codegen_json_file_name: str):
    # Open up 99_mre_<leaderclass>traits_for_codegen.json and write tooltips for a class
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)
    leadermaking_tt_filename = f"{base_filename}_leadermaking_tooltips.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_tt_filename
    )
    with open(input_codegen_json_file_name, "w") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    detected_leader_class = input_codegen_json_file_name('_')[2]
    tooltips_blob_for_writing = iterate_traits_make_leadermaking_tooltips_code(
        buffer, for_class=detected_leader_class)
    with open(output_file_name, "wb") as leadermaking_effects_output:
        sys.stdout.write(f"Writing {detected_leader_class} leadermaking tooltips code to {leadermaking_effects_output.name}\n")
        leadermaking_effects_output.write(
            tooltips_blob_for_writing.encode('utf-8')
        )

def write_leadermaking_button_effects_to_file(input_codegen_json_file_name):
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)
    leadermaking_button_effects_outfile = f"{base_filename}_leadermaking_tooltips.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_button_effects_outfile
    )
    with open(input_codegen_json_file_name, "w") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    detected_leader_class = input_codegen_json_file_name('_')[2]
    tooltips_blob_for_writing = iterate_traits_make_leadermaking_effects_code(
        buffer, for_class=detected_leader_class)
    with open(output_file_name, "wb") as leadermaking_effects_output:
        sys.stdout.write(f"Writing {detected_leader_class} leadermaking tooltips code to {leadermaking_effects_output.name}\n")
        leadermaking_effects_output.write(
            tooltips_blob_for_writing.encode('utf-8')
        )

def gen_xvcv_mdlc_leader_making_clear_values_effect():
    """ Print out the entire 'xvcv_mdlc_leader_making_clear_values_effect' 
    For this we have to iterate subclasses, traits, and print updated trigger for copy/paste
    It's a bit much to do by hand, and we already have the data, so let's priinttttt
    """
    preamble = """
xvcv_mdlc_leader_making_clear_values_effect = {
    optimize_memory
    if = {
        limit = { xvcv_mdlc_leader_making_picked_any_skill_level_trigger = yes }
        xvcv_mdlc_leader_making_clear_skill_levels_effect = yes
    }"""
    closing = """    xvcv_mdlc_leader_making_clear_traits_variables_effect = yes
}
"""
    """ This effect has 3 conditionals at the top-level, for each class,
    and inside of each block of conditionals, it has that class' traits
    We will have to iterate the 3 data files in this single method
    """
    classes_data = {
        "commander": [],
        "scientist": [],
        "official": []
    }
    large_if_clauses_for_all_classes = []
    for input_codegen_json_file_name in INPUT_FILES_FOR_CODEGEN:
        # Go over the files, do all common/veteran/paragon traits for each class
        input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
        buffer = ''
        with open(input_file_path, "r") as source_codegen_data:
            buffer = json_load(source_codegen_data)
            # We only want leadermaking
        file_leader_class = input_codegen_json_file_name.split('_')[2]
        for rarity in RARITIES:
            # print(f"Looking thru {input_codegen_json_file_name} for {file_leader_class} {rarity} traits..")
            # We have got to combine all the traits now, into one list for the class
            classes_data[file_leader_class] = classes_data[file_leader_class] + buffer["leader_making_traits"][rarity]
    # After collection, iterate each class' traits and make the "clear" commands 
    for leader_class in LEADER_CLASSES:
        class_specific_if_limit_then_clear_lines = generate_class_specific_lines_for_leader_making_clear_values_effect(
            classes_data[leader_class], for_class=leader_class
        )
        large_if_clauses_for_all_classes.append(class_specific_if_limit_then_clear_lines)
    compiled_trigger = f"""{preamble}
{"".join(sorted(large_if_clauses_for_all_classes))}
{closing}"""
    return compiled_trigger

def generate_class_specific_lines_for_leader_making_clear_values_effect(list_of_traits, for_class):
    # TODO: Exclude core_modifying traits that we dont want ?

    print(f"Generatint clear values effects for {for_class}")
    opening_lines = f"""
    #{for_class}
    if = {{
        limit = {{ has_country_flag = xvcv_mdlc_leader_class_set_to_{for_class} }}"""
    closing_lines = f"""        remove_country_flag = xvcv_mdlc_leader_class_set_to_{for_class}
    }}"""
    trait_limit_declarations = []
    for leader_trait in list_of_traits:
        trait_name = [*leader_trait][0]
        trait_limit_line = f"        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }} remove_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }}"
        trait_limit_declarations.append(trait_limit_line)
    # Preserve this during autogeneration
    add_custom_traits_class_block = f"""
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }}"""
    trait_limit_declarations.append(add_custom_traits_class_block)
    class_specific_clear_values_lines = f"""{opening_lines}{"\n".join(sorted(trait_limit_declarations))}
{closing_lines}"""
    return class_specific_clear_values_lines

def gen_xvcv_mdlc_leader_making_start_button_effect(organized_traits_dict, for_class):
    """ Write out event_target:xvcv_mdlc_leader_making_target values for each leader class """
    wrapper_indentation = "                    "
    indentation = "                        "
    leader_making_target_conditional = (
        "    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }} }} "
        "add_trait_no_notify = {trait_name} }}"
    )
    header = """
#{leader_class}
event_target:xvcv_mdlc_leader_making_target = {{"""
    closing = "}\n"
    conditional_statement_list = []
    for rarity_level in RARITIES:
        if not organized_traits_dict['leader_making_traits'].get(rarity_level):
            continue
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            conditional_statement_list.append(
                leader_making_target_conditional.format(for_class=for_class, trait_name=trait_name)
            )
    for subclass in LEADER_SUBCLASSES:
        # Make the add_trait expression for this leader class, so 4 items in total
        # The game is checking country flags to see if the subclass flag is set ("picked")
        # And then adds the subclass to the leader
        if for_class in subclass:
            conditional_statement_list.append(
                leader_making_target_conditional.format(for_class=for_class, trait_name=subclass)
            )
    # Append memory backup and shared memory
    conditional_statement_list.append(f"""    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }} }} add_trait_no_notify = xvcv_mdlc_leader_trait_memory_backup }}
    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }} }} add_trait_no_notify = xvcv_mdlc_leader_trait_shared_memory }}""")

    return f"""{header.format(leader_class=for_class)}
{"\n".join(conditional_statement_list)}
{closing}"""

### CORE_MODIFYING ###
def gen_core_modifying_trait_gui_code(
    leader_class, trait_name, column_num, row_num,
    gfx_sprite_name,
    is_xvcv_custom_trait=False, is_veteran_trait=False, is_destiny_trait=False
):
    root_gfx_name = "GFX_xvcv_mdlc_leader_trait_background"
    effect_button_background_gfx = f"{root_gfx_name}_green"
    effect_button_background_gfx_red = f"{root_gfx_name}_red"
    if is_veteran_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_veteran"
        effect_button_background_gfx_red = f"{effect_button_background_gfx}_red"
    elif is_destiny_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_destiny"
        effect_button_background_gfx_red = f"{effect_button_background_gfx}_red"
    return f"""
# {leader_class}: {trait_name}
containerWindowType = {{
    name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}"
    position = {{ x = @xvcv_mdlc_core_modifying_trait_position_column_{column_num} y = @xvcv_mdlc_core_modifying_trait_position_row_{row_num} }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_bg"
        position = {{ x = @xvcv_mdlc_core_modifying_traits_background_offset_width y = @xvcv_mdlc_core_modifying_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_bg"
        position = {{ x = @xvcv_mdlc_core_modifying_traits_background_offset_width y = @xvcv_mdlc_core_modifying_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx_red}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect"
    }}
}}
"""

def gen_core_modifying_leader_subclass_gui_code(
    subclass: str, column_num: int, row_num: int
) -> str:
    """ Subclass pickers for the core-modifying GUI"""
    leader_class = subclass.split('_')[1]
    return f"""
#{leader_class} #{subclass} #{LEADER_SUBCLASSES_NAMES[subclass]}
containerWindowType = {{
    name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{subclass}"
    position = {{ x = @xvcv_mdlc_core_modifying_trait_position_column_{column_num} y = @xvcv_mdlc_core_modifying_trait_position_row_{row_num} }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{subclass}_add"
        position = {{ x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }}
        spriteType = "GFX_leader_{subclass}_medium"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{subclass}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{subclass}_remove"
        position = {{ x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }}
        spriteType = "GFX_leader_{subclass}_medium_red"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{subclass}_remove_button_effect"
    }}
}}
"""

def gen_core_modifying_button_effects_code(
    leader_class, trait_name,
    is_veteran_trait=False, is_destiny_trait=False,
    required_subclass: str='', prerequisites: list = [],
    requires_paragon_dlc: bool=False
):
    # This needs to generate two effects: add, and remove
    # xvcv_mdls_button_effects_core_modifying_traits_<LEADER_CLASS>_customgui.txt
    trait_ends_in_num = trait_name[-1].isdigit()
    needs_remove_tier_num_trait_effect = True if trait_ends_in_num else False
    if trait_ends_in_num:
        trait_name_no_tier = trait_name.rsplit('_',1)[0]
    else:
        trait_name_no_tier = trait_name
    # Veteran & destinty traits need slightly altered trigger names
    alt_trigger_name = ""
    if is_veteran_trait:
        alt_trigger_name = "alt_"
    elif is_destiny_trait:
        alt_trigger_name = "alt_2_"

    # commend out skill level trigger if it's not a veteran trait
    trait_class = "common"
    if is_veteran_trait:
        trait_class = "veteran"
    elif is_destiny_trait:
        trait_class = "destiny"
    trait_comment = f"#{trait_class} trait"

    allowances = []
    allowances.append(f"custom_tooltip = xvcv_mdlc_core_modifying_tooltip_add_{leader_class}_{trait_name}")
    if required_subclass:
        allowances.append(
            "xvcv_mdlc_core_modifying_requires_ruler_subclass_or_focus_trigger = "
            f"{{ CLASS = {leader_class} ID = {required_subclass} }}"
        )
    allowances.append(f"xvcv_mdlc_core_modifying_trait_cost_{alt_trigger_name}trigger = yes")
    allowances.append(f"xvcv_mdlc_core_modifying_trait_points_{alt_trigger_name}trigger = yes")
    # requires skill level trigger
    if is_veteran_trait or is_destiny_trait:
        allowances.append(f"xvcv_mdlc_core_modifying_trait_skill_level_{alt_trigger_name}trigger = yes")
    allowances.append("xvcv_mdlc_core_modifying_trait_max_number_trigger = yes")
    if requires_paragon_dlc:
        allowances.append("has_paragon_dlc = yes")
    # Get fancy about picking up DLC requirements per trait
    if dlc_dependecy := TRAITS_REQUIRING_DLC.get(trait_name):
        allowances.append(f"{dlc_dependecy} = yes")
    # Assuming that prerequisites will always be tech *fingers crossed*
    if len(prerequisites):
        for tech in prerequisites:
            allowances.append(f"has_technology = {tech}")

    effects = []
    if needs_remove_tier_num_trait_effect:
        effects.append(
            f"xvcv_mdlc_core_modifying_remove_tier_1_or_2_traits_effect = {{ ID = {trait_name_no_tier} }}"
        )
    effects.append(
        f"xvcv_mdlc_core_modifying_trait_pick_effect = {{ CLASS = {leader_class} ID = {trait_name} }}"
    )
    effects.append(
        f"hidden_effect = {{ xvcv_mdlc_core_modifying_trait_add_{alt_trigger_name}effect = yes }}"
    )

    return f"""
#{trait_name} {trait_comment}
xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect = {{
    potential = {{
        ruler = {{ NOT = {{ has_trait = {trait_name} }} }}
    }}
    allow = {{
        {"\n        ".join(allowances)}
    }}
    effect = {{
        {"\n        ".join(effects)}
    }}
}}
xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect = {{
    potential = {{
        ruler = {{ has_trait = {trait_name} }}
    }}
    allow = {{ always = yes }}
    effect = {{
        custom_tooltip = xvcv_mdlc_core_modifying_tooltip_remove_{leader_class}_{trait_name}
        hidden_effect = {{
            ruler = {{ remove_trait = {trait_name} }}
            xvcv_mdlc_core_modifying_trait_remove_{alt_trigger_name}effect = yes
        }}
    }}
}}
"""

def iterate_traits_make_coremodifying_gui_code(organized_traits_dict, for_class: str):
    """ The core-modifying GUI sections for leader classes are oddly shaped.
    the 'admiral' section has to have shorter rows than the other sections, but 
    only for the first 3 rows."""

    header_classname_spaced = ' '.join([char for char in for_class])
    header = gui_header.format(
        classname=header_classname_spaced,
        now=str(datetime.now())
    )
    footer = gui_footer.format(
        classname=header_classname_spaced
    )
    gui_code_bloblist = [header,]
    # To accomodate the irregular shape of the container,
    # The first row for Commander has 4, the second row has 5, and the rest are 6 
    row_width_limits = {
        "1": 4,
        "2": 5
    }
    trait_column_num = 3 if for_class == "official" else 2  # offset for the subclass pickers
    trait_row_num = 1
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict["core_modifying_traits"][rarity_level]:
            trait_name = [*leader_trait][0]
            root = leader_trait[trait_name]
            trait_gui_code = gen_core_modifying_trait_gui_code(
                leader_class=for_class,
                gfx_sprite_name=root['gfx'],
                trait_name=trait_name,
                column_num=trait_column_num,
                row_num=trait_row_num,
                is_veteran_trait=(root.get('rarity')=="veteran"),
                is_destiny_trait=(root.get('rarity')=="paragon"),
            )
            # Advance the x / y coordinates
            trait_column_num = trait_column_num + 1
            if for_class=="commander":
                # Special maths rules
                if trait_row_num == 1:
                    # Go to the next row after 4 traits
                    if trait_column_num > 4:
                        trait_row_num = trait_row_num + 1
                        trait_column_num = 1
                elif trait_row_num == 2:
                    # Go to the next row after 5 traits
                    if trait_column_num > 5:
                        trait_row_num = trait_row_num + 1
                        trait_column_num = 1
                else:
                    # Permit only 6 traits in a row therafter, like normal
                    if trait_column_num > 6:
                        trait_column_num = 1
                        trait_row_num = trait_row_num + 1
            else:
                # No special x / y rules for the other classes
                if trait_column_num > 6:
                    trait_column_num = 1
                    trait_row_num = trait_row_num + 1
            gui_code_bloblist.append(trait_gui_code)

    gui_code_bloblist.append(footer)
    return ''.join(gui_code_bloblist)

def iterate_subclasses_make_core_modifying_subclasses_gui_code(subclasses_list: List[str]) -> str:
    """ Iterate over a SORTED LIST of subclasses, 4 each per class
    I'm too tired to divide subclasses by classes and then iterate leader classes
    to do each subclass, so here just make gui code for 4 subclasses and
    reset the column number after every 4
    """
    header = """
############################
## {leader_class} SUBCLASSES
############################
"""
    gui_blob_list = []
    row_num = 1
    column_num = 1
    for subclass in subclasses_list:
        # Cheat a little, for every 4 subclasses, reset the column, but keep the same row number
        # Then we just carefully copy/paste the subclasses into their respective spots in the GUI file
        if subclass in EXCLUDE_SUBCLASSES_FROM_CORE_MODIFYING:
            continue
        if column_num == 1:
            gui_blob_list.append(
                header.format(leader_class=subclass.split('_')[1])
            )
        subclass_gui_code = gen_core_modifying_leader_subclass_gui_code(
            subclass, column_num=column_num, row_num=row_num
        )
        gui_blob_list.append(subclass_gui_code)
        column_num = column_num + 1
        if column_num > 4:
            column_num = 1
    return "".join(gui_blob_list)

def gen_xvcv_mdlc_core_modifying_reset_traits_button_effect_lines(input_files_list):
    """ Print the lines that get pasted in the middle so all the new traits and subclasses get reset
    when players click the brain button in the middle.
        Then these lines get pasted in the effect.
    """
    effect_contents_items = []
    ruler_effect_line = (
        "if = {{ limit = {{ has_trait = {trait_name} }} remove_trait = {trait_name} prev ="
        " {{ xvcv_mdlc_core_modifying_trait_return_cost_{alt_modifier}effect = yes }} }}"
    )
    alt_modifier_lookup = {
        "veteran": "alt_",
        "paragon": "alt_2_"
    }
    for trait_json_data_path in input_files_list:
        with open(trait_json_data_path, "r") as codegen_stream:
            _tmp = json_load(codegen_stream)
            for rarity in RARITIES:
                if not _tmp['core_modifying_traits'].get(rarity):
                    continue
                for trait in _tmp['core_modifying_traits'][rarity]:
                    trait_name = [*trait][0]
                    root = trait[trait_name]
                    alt_modifier = alt_modifier_lookup.get(
                        root['rarity'], ""
                    )
                    effect_contents_items.append(
                        ruler_effect_line.format(trait_name=trait_name, alt_modifier=alt_modifier)
                    )
    for subclass in LEADER_SUBCLASSES:
        alt_modifier = ""
        effect_contents_items.append(
            ruler_effect_line.format(trait_name=subclass, alt_modifier=alt_modifier)
        )
    return "\n".join(effect_contents_items)


# Generic version (can be used with both leader_making and core_modifying)
def iterate_traits_make_feature_button_effects_code(organized_traits_dict, for_class, feature):
    leader_trait_button_effects_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict[f"{feature}_traits"][rarity_level]:
            trait_name = [*leader_trait][0]
            root = leader_trait[trait_name]
            if feature == LEADER_MAKING:
                feature_button_effects_code = gen_leader_making_button_effects_code(
                    leader_class=for_class,
                    trait_name=trait_name,
                    is_veteran_trait=(root.get('rarity')=="veteran"),
                    is_destiny_trait=(root.get('rarity')=="paragon"),
                    required_subclass=root.get('required_subclass', None),
                    prerequisites=root.get('prerequisites', [])
                )
            elif feature == CORE_MODIFYING:
                if EXCLUDE_TRAITS_FROM_CORE_MODIFYING.get(trait_name):
                    continue
                feature_button_effects_code = gen_core_modifying_button_effects_code(
                    leader_class=for_class,
                    trait_name=trait_name,
                    is_veteran_trait=(root.get('rarity')=="veteran"),
                    is_destiny_trait=(root.get('rarity')=="paragon"),
                    required_subclass=root.get('required_subclass', None)
                )
                
            leader_trait_button_effects_copypaste_blob.append(feature_button_effects_code)
    return '\n'.join(leader_trait_button_effects_copypaste_blob)


    sys.exit("iterate_traits_make_coremodifying_effects_code not implemented yet.")

def gen_xvcv_mdlc_core_modifying_ruler_traits_trigger(input_files_list):
    """ Entire trigger with updated list of 3.10 traits for core modifying. for copy/paste """
    indentation = " "*8
    preamble = """
xvcv_mdlc_core_modifying_ruler_traits_trigger = {
    optimize_memory
    OR = {"""
    closing = """    }
}
"""
    buffer = set()
    for trait_json_data_path in input_files_list:
        with open(trait_json_data_path, "r") as codegen_stream:
            _tmp = json_load(codegen_stream)
            for rarity in RARITIES:
                if not _tmp['core_modifying_traits'].get(rarity):
                    continue
                trait_names_list = [
                    [*trait][0] for trait in _tmp['core_modifying_traits'][rarity]
                ]
                buffer = buffer | set(trait_names_list)

    trait_conditions_list = []
    for subclass in LEADER_SUBCLASSES:
        trait_conditions_list.append(
            f"{indentation}has_trait = {subclass}"
        )
    for unique_trait in buffer:
        trait_conditions_list.append(
            f"{indentation}has_trait = {unique_trait}"
        )
    compiled_trigger = f"""{preamble}
{"\n".join(sorted(trait_conditions_list))}
{closing}"""
    return compiled_trigger


def generate_mod_ready_code_files():
    """ This process will make 3 sets of the below files for each leader class, so 18 in total:
        Replacing 'commander' with 'official and 'scientist' for the other 2 sets.

        86_mre_autogenerated_core_modifying_commander_gui.txt
        86_mre_autogenerated_core_modifying_commander_effects.txt
        86_mre_autogenerated_core_modifying_commander_tooltips.txt
        86_mre_autogenerated_leader_making_commander_gui.txt
        86_mre_autogenerated_leader_making_commander_effects.txt
        86_mre_autogenerated_leader_making_commander_tooltips.txt

        Effects and tooltips files can directly replace game mod files,
        but only the code in each gui.txt file needs to be copy/pasted into its destination.
    """
    """ TODO: Deposit localisation and button effects directly into their game code files """
    for input_file in INPUT_FILES_FOR_CODEGEN:
        for feature_type in (LEADER_MAKING, CORE_MODIFYING):
            for generated_code_type in ["effects","gui","tooltips"]:
                run_codegen_process_for_ingame_feature(
                    input_file, generated_code_type=generated_code_type, feature=feature_type,
                    write_directly_to_mod_files=True
                )


# Generic version
def iterate_traits_make_feature_tooltips_code(
        organized_traits_dict, for_class, feature="leader_making", machine_localisations_map=None
    ):
    """ Generate tooltips code for either 'leader_making' or 'core_modifying' feature """
    leader_tooltips_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict[f"{feature}_traits"][rarity_level]:
            tooltip_code_for_leadermaking_trait = create_tooltip_for_leader(
                trait_dict=leader_trait, leader_class=for_class, feature=feature,
                machine_localisations_map=machine_localisations_map
            )
            leader_tooltips_copypaste_blob.append(tooltip_code_for_leadermaking_trait)
    return LOCALISATION_HEADER + ''.join(leader_tooltips_copypaste_blob)

## These methods are wrappers so we can run more things from mre_run_trait_pipeline
def pipeline_make_leader_start_button_code():
    """ Wrapper for making leader start button code from run_mre_trait_pipeline """
    content_blob = []
    for codegen_ready_file in INPUT_FILES_FOR_CODEGEN:
        leader_class = codegen_ready_file.split('_')[2]
        input_filepath = os.path.join(BUILD_FOLDER, codegen_ready_file)
        with open(input_filepath, "r") as traits_json_file:
            buffer = json_load(traits_json_file)
        trigger_blob_for_writing = gen_xvcv_mdlc_leader_making_start_button_effect(
            buffer, for_class=leader_class)
        content_blob.append(trigger_blob_for_writing)
    outfile_path = os.path.join(
        BUILD_FOLDER,
        "85_leader_making_start_button_effect.txt"
    )
    with open(outfile_path, "w") as trigger_file_output:
        sys.stdout.write(f"Writing leader_making_start_button_effect code to {trigger_file_output.name}\n")
        trigger_file_output.write(
            "\n".join(content_blob)
        )

def pipeline_make_xvcv_mdlc_core_modifying_ruler_traits_trigger():
    input_files_in_build_folder = [
        os.path.join(BUILD_FOLDER, codegen_ready_file)
        for codegen_ready_file in INPUT_FILES_FOR_CODEGEN
    ]
    trigger_blob_for_writing = gen_xvcv_mdlc_core_modifying_ruler_traits_trigger(input_files_in_build_folder)
    outfile_path = os.path.join(
        BUILD_FOLDER,
        "85_core_modifying_modifying_ruler_trait_trigger.txt"
    )
    with open(outfile_path, "w") as trigger_file_output:
        sys.stdout.write(f"Writing core modifying trigger code to {trigger_file_output.name}\n")
        trigger_file_output.write(
            trigger_blob_for_writing
        )

def pipeline_make_leader_making_clear_values_effect():
    blob_for_writing = gen_xvcv_mdlc_leader_making_clear_values_effect()
    outfile_path = os.path.join(
        BUILD_FOLDER,
        "85_leader_making_clear_values_effect.txt"
    )
    with open(outfile_path, "w") as trigger_file_output:
        sys.stdout.write(f"Writing leader making trigger code to {trigger_file_output.name}\n")
        trigger_file_output.write(
            blob_for_writing
        )
        print("!!!Remember to add in the lines for each of the subclasses!!!")

def pipeline_make_xvcv_mdlc_core_modifying_reset_traits_button_effect_lines():
    input_files_in_build_folder = [
        os.path.join(BUILD_FOLDER, codegen_ready_file)
        for codegen_ready_file in INPUT_FILES_FOR_CODEGEN
    ]
    blob_for_writing = gen_xvcv_mdlc_core_modifying_reset_traits_button_effect_lines(input_files_in_build_folder)
    outfile_path = os.path.join(
        BUILD_FOLDER,
        "85_core_modifying_reset_traits_button_effect.txt"
    )
    with open(outfile_path, "w") as trigger_file_output:
        sys.stdout.write(f"Writing core modifying trigger code to {trigger_file_output.name}\n")
        trigger_file_output.write(
            blob_for_writing
        )

def pipeline_make_core_modifying_subclasses_gui_code():
    target_file = "85_core_modifying_subclasses_gui_code.txt"
    build_path_target = os.path.join(
        BUILD_FOLDER, target_file
    )
    gui_blob_for_writing = iterate_subclasses_make_core_modifying_subclasses_gui_code(LEADER_SUBCLASSES)
    with open(build_path_target, "w") as subclasses_gui_outfile:
        subclasses_gui_outfile.write(gui_blob_for_writing)
    print(f"Wrote CORE MODIFYING SUBCLASSES GUI code to {build_path_target}")
    print("This needs to be copy/pasted into the core modifying gui file")

def pipeline_make_core_modifying_list_traits_by_class():
    """ Collect & list traits for a class which have subclass requirements
        These are used to check in the core modifying gui
        to prevent players from removing a subclass while depdendent traits are picked
    """
    subtraits_names = {
        "commander": [],
        "official": [],
        "scientist": []
    }
    buffer = ''
    for codegen_ready_file in INPUT_FILES_FOR_CODEGEN:
        leader_class = codegen_ready_file.split('_')[2]
        input_filepath = os.path.join(BUILD_FOLDER, codegen_ready_file)
        with open(input_filepath, "r") as traits_json_file:
            buffer = json_load(traits_json_file)
        for rarity_level in RARITIES:
            # iterate common, veteran, paragon
                for leader_trait in buffer[f"core_modifying_traits"][rarity_level]:
                    trait_name = [*leader_trait][0]
                    root = leader_trait[trait_name]
                    if root.get('required_subclass'):
                        subtraits_names[leader_class].append(
                            f"has_trait = {trait_name}"
                        )
    outfile_name = "85_core_modifying_subclass_dependent_traits.txt"
    outfile_path = os.path.join(
        BUILD_FOLDER, outfile_name
    )
    with open(outfile_path, "w") as outfile_object:
        for ruler_class in LEADER_CLASSES:
            a_blob_00 = f"""#{ruler_class} traits requiring subclasses:
{"\n".join(sorted(subtraits_names[ruler_class]))}
"""
            outfile_object.write(a_blob_00)
    print("I am so tired")
    print(f"Look in {outfile_name}")



##################
### THE BIG ONE ##
##################

def run_codegen_process_for_ingame_feature(
    input_codegen_json_file_name,
    generated_code_type,
    feature,
    write_directly_to_mod_files=False
):
    """ Do all code gen for core_modifying and leader_making
    This assumes it is being called from the mod root, not mre_code_tools
    so it can find the common and localisation folders
    """
    buffer = ''
    detected_leader_class = input_codegen_json_file_name.split('_')[2]
    leadermaking_code_outfile = f"86_mre_autogenerated_{feature}_{detected_leader_class}_{generated_code_type}.txt"
    if write_directly_to_mod_files:
        if generated_code_type == "gui":
            output_file_name = os.path.join(
                BUILD_FOLDER,
                leadermaking_code_outfile
            )
        else:
            # There's a dictionary with all the output files mapped
            # For each feature, code type, and class .. It'll write 12 of those files
            # We dont write to the GUI files, so that is why the above is excluded
            output_file_name = OUTPUT_FILES_DESTINATIONS[feature][generated_code_type][detected_leader_class]
    else:
        output_file_name = os.path.join(
            BUILD_FOLDER,
            leadermaking_code_outfile
        )
    input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
    with open(input_file_path, "r") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    
    generated_leadermaking_code_blob = ''
    if generated_code_type == "tooltips":
        machine_localisations_file_path = os.path.join(
            BUILD_FOLDER, MACHINE_LOCALISATIONS_MAPFILE
        )
        localisations_buffer = {}
        with open(machine_localisations_file_path, "r") as machine_map_data:
            localisations_buffer = json_load(machine_map_data)
        # This method works for both core_modifying and leader_making
        generated_leadermaking_code_blob = iterate_traits_make_feature_tooltips_code(
            buffer,
            for_class=detected_leader_class,
            feature=feature,
            machine_localisations_map=localisations_buffer
        )
    elif generated_code_type == "gui":
        if feature == CORE_MODIFYING:
            generated_leadermaking_code_blob = iterate_traits_make_coremodifying_gui_code(
                buffer,
                for_class=detected_leader_class
            )
        elif feature == LEADER_MAKING:
            generated_leadermaking_code_blob = iterate_traits_make_leadermaking_gui_code(
                buffer,
                for_class=detected_leader_class
            )
    elif generated_code_type == "effects":
        generated_leadermaking_code_blob = iterate_traits_make_feature_button_effects_code(
            buffer,
            for_class=detected_leader_class,
            feature=feature
        )
    with open(output_file_name, "wb") as leadermaking_code_outfile:
        sys.stdout.write(f"Writing {detected_leader_class} {feature} {generated_code_type} code to {output_file_name}\n")
        mod_file_encoding = 'utf-8-sig' if generated_code_type == 'tooltips' else 'utf-8'
        leadermaking_code_outfile.write(
            generated_leadermaking_code_blob.encode(mod_file_encoding)
        )


if __name__ == "__main__":
    start_time = time.time()
    parser = argparse.ArgumentParser(
        prog="0xRetro Machine & Robot Expansion Mod Codegen Tools",
        description="Automatically spew out mod code"
    )
    parser.add_argument(
        '--infile',
        help='A traits JSON file that we processed, like 99_mre_commander_traits_for_codegen.json, created from mre_process_traits_for_codegen.py.',
        required=False
    )
    parser.add_argument(
        '--tooltips',
        help="Generate M&RE trait tooltips, given a traits JSON file that was processed by mre_process_traits_for_codegen",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--effects',
        help="Generate effects code from trait files",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--gui',
        help="Generate GUI code for leadermaking feature, from trait files",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--core_trigger',
        help="Generate xvcv_mdlc_core_modifying_ruler_traits_trigger",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--core_reset',
        help="Generate hidden effect list for xvcv_mdlc_core_modifying_reset_traits_button_effect",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--leader_fx1',
        help="Generate xvcv_mdlc_leader_making_clear_values_effect",
        action="store_true",
        required=False
    )
    parser.add_argument(
        "--core_subclasses_gui",
        help="Generate GUI code for subclass pickers for core-modifying feature",
        action="store_true",
        required=False
    )
    parser.add_argument(
        "--leader_start_button",
        help="Generate contents for leader_making_start_button effect. Three effects blocks per leader class",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--core_ruler_subclass_traits',
        help="Make a list of traits that require subclasses, for the core modifying GUI",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--process_all',
        help="The Big One. Generate M&RE tooltips, GUI code, button effects code, assuming all traits files were processed by mre_process_traits_for_codegen",
        action="store_true"
    )
    args = parser.parse_args()
    # Args that dont need an infile
    if args.process_all:
        generate_mod_ready_code_files()
        sys.exit()

    if args.leader_start_button:
        """ Iterate the 99_ files, emit blocks of code for each leader class
        that then gets copy/pasted by a hum0n into xvcv_mdlc_button_effects_leader_making_main_customgui.txt"""
        pipeline_make_leader_start_button_code()
        sys.exit()
    if args.core_trigger:
        pipeline_make_xvcv_mdlc_core_modifying_ruler_traits_trigger()
        sys.exit()
    if args.leader_fx1:
        pipeline_make_leader_making_clear_values_effect()
        sys.exit()
    if args.core_reset:
        pipeline_make_xvcv_mdlc_core_modifying_reset_traits_button_effect_lines()
        sys.exit()
    if args.core_subclasses_gui:
        pipeline_make_core_modifying_subclasses_gui_code()
        sys.exit()
    if args.core_ruler_subclass_traits:
        pipeline_make_core_modifying_list_traits_by_class()
        sys.exit()

    buffer = ''
    infile_no_ext = args.infile.rsplit('.',1)[0]
    with open(args.infile) as organized_traits_file:
        buffer = json_load(organized_traits_file)

    if args.tooltips:
        target_file = f"{infile_no_ext}_leadermaking_tooltips.txt"
        detected_leader_class = args.infile.split('_')[2]
        tooltips_blob_for_writing = iterate_traits_make_leadermaking_tooltips_code(
            buffer, for_class=detected_leader_class)
        with open(target_file, "wb") as leadermaking_effects_output:
            sys.stdout.write(f"Writing leadermaking tooltips code to {leadermaking_effects_output.name}\n")
            leadermaking_effects_output.write(
                tooltips_blob_for_writing.encode('utf-8')
            )
        sys.exit()
    if args.effects:
        detected_leader_class = args.infile.split('_')[2]
        effects_blob_for_writing = iterate_traits_make_leadermaking_effects_code(
            buffer, for_class=detected_leader_class)
        with open(f"{infile_no_ext}_leadermaking_effects.txt", "wb") as leadermaking_effects_output:
            sys.stdout.write(f"Writing leadermaking effects code to {leadermaking_effects_output.name}\n")
            leadermaking_effects_output.write(
                effects_blob_for_writing.encode('utf-8')
            )
            sys.exit()
    if args.gui:
        detected_leader_class = args.infile.split('_')[2]
        gui_blob_for_writing = iterate_traits_make_leadermaking_gui_code(
            buffer, for_class=detected_leader_class)
        with open(f"{infile_no_ext}_leadermaking_gui.txt", "wb") as leadermaking_gui_output:
            sys.stdout.write(f"Writing leadermaking gui code to {leadermaking_gui_output.name}\n")
            leadermaking_gui_output.write(
                gui_blob_for_writing.encode('utf-8')
            )
            sys.exit()
