from json import load as json_load
import os
from pipeline.mre_common_vars import AUTOGENERATED_HEADER, INPUT_FILES_FOR_CODEGEN, LEADER_CLASSES, LEADER_SUBCLASSES, RARITIES, TRAITS_REQUIRING_DLC, TRAITS_REQUIRING_ORIGINS
from pipeline.transform.leader_trait_triggers import process_complex_tech_requirements

def gen_leader_making_button_effects_code(
    leader_class, trait_name,
    is_veteran_trait=False, is_destiny_trait=False,
    required_subclass: str='', prerequisites: list=[],
    requires_paragon_dlc: bool=False  # Kluge to take advantage of 'requires_paragon_dlc' key
):
    # This can be used for each leader class
    # \common\button_effects\xvcv_mdlc_button_effects_leader_making_<LEADER_CLASS>_customgui.txt
    alt_trigger_name = ""
    if is_veteran_trait:
        alt_trigger_name = "alt_"
    if is_destiny_trait:
        alt_trigger_name = "alt_2_"
    vet_or_destiny_trait_comment = ''
    if is_veteran_trait:
        vet_or_destiny_trait_comment = "#veteran trait"
    if is_destiny_trait:
        vet_or_destiny_trait_comment = "#destiny trait"

    allowances = []
    allowances.append(
        f"xvcv_mdlc_leader_making_trait_pick_trigger = {{ CLASS = {leader_class} ID = {trait_name} }}"
    )
    if required_subclass:
        allowances.append(
            f"xvcv_mdlc_leader_making_requires_leader_subclass_trigger = {{ CLASS = {leader_class} ID = {required_subclass} }}"
        )
    allowances.append(f"xvcv_mdlc_leader_making_trait_cost_{alt_trigger_name}trigger = yes")
    allowances.append(f"xvcv_mdlc_leader_making_trait_points_{alt_trigger_name}trigger = yes")
    if is_veteran_trait or is_destiny_trait:
        allowances.append(f"xvcv_mdlc_leader_making_trait_skill_level_{alt_trigger_name}trigger = yes")
    allowances.append("xvcv_mdlc_leader_making_trait_max_number_trigger = yes")
    allowances.append(f"xvcv_mdlc_leader_making_picked_class_{leader_class}_trigger = yes")
    if requires_paragon_dlc:
        allowances.append("has_paragon_dlc = yes")
    # Assuming that prerequisites will always be tech *fingers crossed*
    # if len(prerequisites):
    #     for tech in prerequisites:
    #         allowances.append(f"has_technology = {tech}")
    if len(prerequisites):
        # breakpoint()
        tech_allowances = process_complex_tech_requirements(prerequisites)
        allowances = allowances + tech_allowances

    # Get fancy about picking up DLC requirements per trait ^^
    if dlc_dependecy := TRAITS_REQUIRING_DLC.get(trait_name):
        allowances.append(f"{dlc_dependecy} = yes")
    if origin_dependency := TRAITS_REQUIRING_ORIGINS.get(trait_name):
        allowances.append(
            f"root = {{ has_origin = {origin_dependency} }}"
        )

    return f"""
#{leader_class} #{trait_name} {vet_or_destiny_trait_comment}
xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect = {{
    potential = {{ always = yes }}
    allow = {{
        {"\n        ".join(allowances)}
    }}
    effect = {{
        xvcv_mdlc_leader_making_trait_pick_effect = {{ CLASS = {leader_class} ID = {trait_name} }}
        hidden_effect = {{ xvcv_mdlc_leader_making_trait_count_points_costs_{alt_trigger_name}effect = yes }}
    }}
}}
"""


def iterate_traits_make_leadermaking_effects_code(organized_traits_dict, for_class):
    leader_making_effects_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]
            leadermaking_effects_code_for_trait = gen_leader_making_button_effects_code(
                leader_class=for_class,
                trait_name=trait_name,
                is_veteran_trait=(root.get('rarity')=="veteran"),
                is_destiny_trait=(root.get('rarity')=="paragon"),
                required_subclass=root.get('required_subclass', None),
                prerequisites=root.get('prerequisites', [])
            )
            leader_making_effects_copypaste_blob.append(leadermaking_effects_code_for_trait)
    return '\n'.join(leader_making_effects_copypaste_blob)


def gen_xvcv_mdlc_leader_making_start_button_effect(organized_traits_dict, for_class):
    """ Write out event_target:xvcv_mdlc_leader_making_target values for each leader class """
    wrapper_indentation = "                    "
    indentation = "                        "
    leader_making_target_conditional = (
        "    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }} }} "
        "add_trait = {{ trait = {trait_name} show_message = no }} }}"
    )
    header = """
#{leader_class}
event_target:xvcv_mdlc_leader_making_target = {{"""
    closing = "}\n"
    conditional_statement_list = []
    for rarity_level in RARITIES:
        if not organized_traits_dict['leader_making_traits'].get(rarity_level):
            continue
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            conditional_statement_list.append(
                leader_making_target_conditional.format(for_class=for_class, trait_name=trait_name)
            )
    for subclass in LEADER_SUBCLASSES:
        # Make the add_trait expression for this leader class, so 4 items in total
        # The game is checking country flags to see if the subclass flag is set ("picked")
        # And then adds the subclass to the leader
        if for_class in subclass:
            conditional_statement_list.append(
                leader_making_target_conditional.format(for_class=for_class, trait_name=subclass)
            )
    # Append memory backup and shared memory
    conditional_statement_list.append(f"""    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }} }} add_trait = {{ trait = xvcv_mdlc_leader_trait_memory_backup show_message = no }} }}
    if = {{ limit = {{ prev = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }} }} add_trait = {{ trait = xvcv_mdlc_leader_trait_shared_memory show_message = no }} }}""")

    return f"""{header.format(leader_class=for_class)}
{"\n".join(conditional_statement_list)}
{closing}"""


def generate_class_specific_lines_for_leader_making_clear_values_effect(list_of_traits, for_class):
    # TODO: Exclude core_modifying traits that we dont want ?

    print(f"Generating clear values effects for {for_class}")
    opening_lines = f"""
    #{for_class}
    if = {{
        limit = {{ has_country_flag = xvcv_mdlc_leader_class_set_to_{for_class} }}"""
    closing_lines = f"""        remove_country_flag = xvcv_mdlc_leader_class_set_to_{for_class}
    }}"""
    trait_limit_declarations = []
    trait_limit_line = "        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }} remove_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }}"
    for leader_trait in list_of_traits:
        trait_name = [*leader_trait][0]
        trait_limit_declarations.append(trait_limit_line.format(for_class=for_class, trait_name=trait_name))
    # Remember to generate subclasses code!
    for subclass_trait in LEADER_SUBCLASSES:
        if for_class in subclass_trait:
            trait_limit_declarations.append(
                trait_limit_line.format(for_class=for_class, trait_name=subclass_trait)
            )
    # Preserve this during autogeneration
    add_custom_traits_class_block = f"""
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }}"""
    trait_limit_declarations.append(add_custom_traits_class_block)
    class_specific_clear_values_lines = f"""{opening_lines}{"\n".join(sorted(trait_limit_declarations))}
{closing_lines}"""
    return class_specific_clear_values_lines


def gen_xvcv_mdlc_leader_making_clear_values_effect():
    """ Print out the entire 'xvcv_mdlc_leader_making_clear_values_effect' 
    For this we have to iterate subclasses, traits, and print updated trigger for copy/paste
    It's a bit much to do by hand, and we already have the data, so let's priinttttt
    """
    preamble = """
xvcv_mdlc_leader_making_clear_values_effect = {
    optimize_memory
    if = {
        limit = { xvcv_mdlc_leader_making_picked_any_skill_level_trigger = yes }
        xvcv_mdlc_leader_making_clear_skill_levels_effect = yes
    }
    set_variable = {
        which = xvcv_mdlc_leader_making_start_number
        value = 1
    }"""
    closing = """    xvcv_mdlc_leader_making_clear_traits_variables_effect = yes
}
"""
    """ This effect has 3 conditionals at the top-level, for each class,
    and inside of each block of conditionals, it has that class' traits
    We will have to iterate the 3 data files in this single method
    """
    classes_data = {
        "commander": [],
        "scientist": [],
        "official": []
    }
    large_if_clauses_for_all_classes = []
    for input_codegen_json_file_name in INPUT_FILES_FOR_CODEGEN:
        # Go over the files, do all common/veteran/paragon traits for each class
        # input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
        buffer = ''
        with open(input_codegen_json_file_name, "r") as source_codegen_data:
            buffer = json_load(source_codegen_data)
            # We only want leadermaking
        filename_itself = input_codegen_json_file_name.split(os.sep)[-1]
        file_leader_class = filename_itself.split('_')[2]
        for rarity in RARITIES:
            # print(f"Looking thru {input_codegen_json_file_name} for {file_leader_class} {rarity} traits..")
            # We have got to combine all the traits now, into one list for the class
            # breakpoint()
            classes_data[file_leader_class] = classes_data[file_leader_class] + buffer["leader_making_traits"][rarity]
    # After collection, iterate each class' traits and make the "clear" commands 
    for leader_class in LEADER_CLASSES:
        class_specific_if_limit_then_clear_lines = generate_class_specific_lines_for_leader_making_clear_values_effect(
            classes_data[leader_class], for_class=leader_class
        )
        large_if_clauses_for_all_classes.append(class_specific_if_limit_then_clear_lines)
    compiled_trigger = f"""{preamble}
{"".join(sorted(large_if_clauses_for_all_classes))}
{closing}"""
    return compiled_trigger



# def write_leadermaking_button_effects_to_file(input_codegen_json_file_name):
#     buffer = ''
#     base_filename =  input_codegen_json_file_name.rsplit('.',1)
#     leadermaking_button_effects_outfile = f"{base_filename}_leadermaking_tooltips.txt"
#     output_file_name = os.path.join(
#         BUILD_FOLDER,
#         leadermaking_button_effects_outfile
#     )
#     with open(input_codegen_json_file_name, "w") as source_codegen_data:
#         buffer = json_load(source_codegen_data)
#     detected_leader_class = input_codegen_json_file_name('_')[2]
#     tooltips_blob_for_writing = iterate_traits_make_leadermaking_effects_code(
#         buffer, for_class=detected_leader_class)
#     with open(output_file_name, "wb") as leadermaking_effects_output:
#         sys.stdout.write(f"Writing {detected_leader_class} leadermaking tooltips code to {leadermaking_effects_output.name}\n")
#         leadermaking_effects_output.write(
#             tooltips_blob_for_writing.encode('utf-8')
#         )
